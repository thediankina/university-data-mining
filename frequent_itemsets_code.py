# -*- coding: utf-8 -*-
"""Галиулина_ПоискЧастыхНаборов_Code.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Y9LqZ3RJXu3nE17-vCM0rsiBMrPhrBx4
"""

!pip install apyori

from apyori import apriori
import gzip
from datetime import datetime
import time
import matplotlib.pyplot as plt
import numpy as np

!wget http://fimi.uantwerpen.be/data/retail.dat.gz
!wget http://fimi.uantwerpen.be/data/accidents.dat.gz

def convert_gzip(filename, length):
  '''
  Convert from bytes to array(arrays) which are split by \n
  : param filename: string gzip archive name
  : param length: integer number of transactions
  :return:
  '''
  this_file = gzip.open(filename, "rb")
  file_content = list(this_file.read())
  a = []
  result = []
  for elem in file_content:
    if elem == 10:
      result.append(a)
      a = []
    else:
      a.append(elem)
  return result[:length]

def get_itemsets_and_supports(apriori_algorithm_result):
    '''
    Get frequent itemsets with their supports from apriori result
    : param apriori_algorithm_result: list of itemsets, supports and etc
    :return:
    '''
    result_list = []
    for record in apriori_algorithm_result:
      result_list.append((record.items, record.support))
    return result_list

def get_apriori_result(transactions, min_support, ordering_method):
  '''
  Run apriori algorithm
  : param transactions: array of array transactions
  : param min_support: real number of minimal support
  : param ordering_method: ordering method for result itemset
  :return:
  '''
  result = list(apriori(transactions, min_support=min_support))
  frequent_itemsets_with_supports = get_itemsets_and_supports(result)
  if ordering_method == "descending_support":
    sorted_by_support = sorted(dict(frequent_itemsets_with_supports).items(), key=lambda i: i[1])
    frequent_itemsets_with_supports = sorted_by_support
  if ordering_method == "lexicographic":
    sorted_by_lexicographic = dict(frequent_itemsets_with_supports)
    frequent_itemsets_with_supports = sorted_by_lexicographic
  return frequent_itemsets_with_supports

transactions = [convert_gzip("retail.dat.gz", 3000), convert_gzip("accidents.dat.gz", 5000)]
min_support = np.arange(0.3, 0.8, 0.1)
ordering_method = ["descending_support", "lexicographic"]
print("number of transactions")
print("retail:    ", len(transactions[0]))
print("accidents: ", len(transactions[1]))
print("\nminimal support values: ", min_support)

def get_execution_time(transactions, ordering_method, min_support=min_support):
  '''
  Measure execution time
  : param transactions: array of array transactions
  : param ordering_method: ordering method for result itemset
  : param min_support: real number of minimal support
  :return:
  '''
  execution_time = []
  number_of_itemsets = []
  for min_support_value in min_support:
    start_time = datetime.now()
    frequent_itemsets_with_supports = get_apriori_result(transactions, min_support_value, ordering_method)
    number_of_itemsets.append(len(frequent_itemsets_with_supports))
    execute_interval = datetime.now() - start_time
    execution_time.append(execute_interval)
    print(frequent_itemsets_with_supports)
  return execution_time, number_of_itemsets

execution_times = []
execution_times.append(get_execution_time(transactions[0], ordering_method[0]))
execution_times.append(get_execution_time(transactions[1], ordering_method[0]))

def convert_seconds(times):
  '''
  Convert seconds in execution time to microseconds
  : param times: array of datetime.timedelta
  return:
  '''
  y = []
  for t in times:
    if t.seconds:
      y.append(int(t.seconds)*1000 + int(t.microseconds))
    else:
      y.append(int(t.microseconds))
  return y

x1 = min_support - 0.015
x2 = min_support + 0.015
y1 = convert_seconds(execution_times[0][0])
y2 = convert_seconds(execution_times[1][0])

plt.title('Speed')
plt.xlabel('minimal support')
plt.ylabel('microseconds')
plt.bar(x1, y1, label = 'retail', width = 0.03)
plt.bar(x2, y2, label = 'accidents', width = 0.03)
plt.legend(loc = 'upper left')
plt.show()

y1 = execution_times[0][1]
y2 = execution_times[1][1]

plt.title('Itemsets')
plt.xlabel('minimal support')
plt.ylabel('count')
plt.bar(x1, y1, label = 'retail', width = 0.03)
plt.bar(x2, y2, label = 'accidents', width = 0.03)
plt.legend(loc = 'upper left')
plt.show()